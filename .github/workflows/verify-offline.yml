name: Verify Offline Resilience

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  offline-check:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
    - uses: actions/checkout@v3

    - name: Install System Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libasound2-dev libdbus-1-dev pkg-config libsystemd-dev dbus python3-dbus alsa-utils dbus-x11 libdbus-glib-1-dev

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: stable
        override: true

    - name: Build
      run: cargo build --release

    - name: Setup Dummy Config (Broken Network)
      run: |
        mkdir -p ~/.config/speechd-ng
        # Point Ollama to unreachable IP to simulate timeout/offline
        # Enable AI to force the code path to try connecting
        cat <<EOF > ~/.config/speechd-ng/Speech.toml
        ollama_url = "http://192.0.2.1:12345" 
        ollama_model = "void"
        enable_ai = true
        passive_confidence_threshold = 0.1
        piper_model = "en_US-lessac-medium"
        tts_backend = "espeak" 
        enable_audio = false
        EOF

    - name: Start Daemon (Background)
      run: |
        # Run dbus-run-session to create a session bus
        # We start the daemon in background
        # We need to export DBUS_SESSION_BUS_ADDRESS for the client
        echo "Starting Daemon..."
    
    - name: Run Resilience Test
      run: |
        # Ensure we have a runtime dir for D-Bus/Alsa owned by runner user
        mkdir -p /home/runner/runtime
        export XDG_RUNTIME_DIR=/home/runner/runtime
        
        # Wrap everything in dbus-run-session so we have a bus
        dbus-run-session -- bash -c '
          # 1. Start Daemon with output captured
          echo "Starting Daemon [Session Bus: $DBUS_SESSION_BUS_ADDRESS]..."
          ./target/release/speechserverdaemon > daemon.log 2>&1 &
          DAEMON_PID=$!
          
          # 2. Wait for service to appear on bus (up to 30s)
          echo "Waiting for org.speech.Service to appear on bus..."
          for i in {1..30}; do
            # Use busctl to look for the service name on the SESSION bus (no --user)
            if busctl list 2>/dev/null | grep -q "org.speech.Service"; then
               echo "Service is UP and owning name after $i seconds."
               break
            fi
            
            # Check if daemon is still alive
            if ! kill -0 $DAEMON_PID 2>/dev/null; then
               echo "::error::Daemon died during startup!"
               cat daemon.log
               ps aux | grep speech
               exit 1
            fi
            
            sleep 1
            if [ $i -eq 30 ]; then
               echo "::error::Timeout waiting for service name!"
               echo "--- Daemon Logs ---"
               cat daemon.log
               echo "--- Bus Status ---"
               busctl list || echo "busctl failed"
               ps aux
               exit 1
            fi
          done

          # 3. Run Benchmark/Check
          echo "Running Client Check..."
          python3 benchmarks/latency_test.py
          CLIENT_EXIT=$?

          if [ $CLIENT_EXIT -ne 0 ]; then
            echo "::error::Client test failed with exit code $CLIENT_EXIT"
            echo "--- Daemon Logs ---"
            cat daemon.log
            kill $DAEMON_PID
            exit 1
          fi

          # 4. Verify Daemon is still alive
          if ! kill -0 $DAEMON_PID; then
            echo "::error::Daemon crashed during execution"
            echo "--- Daemon Logs ---"
            cat daemon.log
            exit 1
          fi

          echo "Offline resilience verified."
          kill $DAEMON_PID
        '
